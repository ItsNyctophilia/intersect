// Initial hash set syntax originally generated by ChatGPT
// and thoroughly modified to the project's parameters.

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>

// Arbitrary starting table size and load factor,
// seems reasonable for default parameters
#define INITIAL_TABLE_SIZE 1000
#define LOAD_FACTOR 0.70

typedef struct hash_node {
	char *word;
	unsigned counter;
	struct hash_node *alt_next;
	struct hash_node *next;
} hash_node;

typedef struct hash_set {
	hash_node **table;
	unsigned size;
	unsigned num_words;
} hash_set;

void hash_set_add_alts(hash_set * set, const char *word, int file_num);

static unsigned int hash(const char *word, int table_size)
{
	// Arbitrary constant used by the djb2 hashing algorithm
	unsigned hash = 5381;
	size_t punc_start_len = 0;
	size_t punc_end_len = 0;
	// The following code is to avoid hashing punctuation such that nodes
	// with the same word (sans punctuation, capitalization-agnostic) will
	// be hashed to the same value
	for (size_t i = 0; i < strlen(word); ++i) {
		if (ispunct(word[i])) {
			++punc_start_len;
			continue;
		}
		break;
	}
	for (size_t i = strlen(word); i > 0; --i) {
		if (ispunct(word[i - 1])) {
			++punc_end_len;
		}
		break;
	}

	for (size_t i = 0; i < strlen(word); i++) {
		// This comparison checks if the punctuation is at the start
		// or end of the word, ignoring punctuation in the middle
		if (ispunct(word[i])
		    && (i < punc_start_len
			|| i > strlen(word) - punc_end_len - 1)) {
			continue;
		}
		hash = ((hash << 5) + hash) + tolower(word[i]);
	}
	return hash % table_size;
}

hash_set *hash_set_create(void)
{
	hash_set *set = malloc(sizeof(hash_set));
	if (!set) {
		return NULL;
	}
	set->table = calloc(INITIAL_TABLE_SIZE, sizeof(hash_node *));
	if (!set->table) {
		return NULL;
	}
	set->size = INITIAL_TABLE_SIZE;
	set->num_words = 0;
	return set;
}

void hash_set_add_word(hash_set * set, const char *word)
{
	if (!set || !word) {
		return;
	}
	// Casting int to float for float division
	if (((float)set->num_words / set->size) > LOAD_FACTOR) {
		int new_size = set->size * 2;
		hash_node **new_table = calloc(new_size, sizeof(hash_node *));
		if (!new_table) {
			return;
		}
		for (size_t i = 0; i < set->size; i++) {
			hash_node *node = set->table[i];
			while (node != NULL) {
				hash_node *next = node->next;
				unsigned index = hash(node->word, new_size);
				node->next = new_table[index];
				new_table[index] = node;
				node = next;
			}
		}
		free(set->table);
		set->table = new_table;
		set->size = new_size;
	}
	unsigned index = hash(word, set->size);
	hash_node *node = set->table[index];
	while (node != NULL) {
		if (strcasecmp(node->word, word) == 0) {
			// Case: alternate spelling found in first file
			hash_set_add_alts(set, word, -1);
			// Set file number to explicit "-1" value for counter-tracking
			// purposes
			return;
		}
		node = node->next;
	}
	node = malloc(sizeof(hash_node));
	if (!node) {
		return;
	}
	node->word = malloc(strlen(word) + 1);
	if (!node->word) {
		free(node);
		return;
	}
	strcpy(node->word, word);
	node->counter = 0;
	node->next = set->table[index];
	node->alt_next = NULL;
	set->table[index] = node;
	++set->num_words;
}

void hash_set_add_alts(hash_set * set, const char *word, int file_num)
// Indexes into an already-populated hash set and adds alternative
// spellings of existing nodes on the top level to the alt_next chain
// off of that node.
{
	if (!set || !word) {
		return;
	}
	unsigned index = hash(word, set->size);
	hash_node *node = set->table[index];

	if (!node) {
		return;
	}
	// The following code block is dumb. It's dumb and looks bad, but
	// I couldn't find a faster way to compare two strings while ignoring
	// trailing and leading punctuation
	// psl == "punctuation start length"
	int old_psl = 0;
	int new_psl = 0;
	for (size_t i = 0; i < strlen(word); ++i) {
		if (ispunct(node->word[i])) {
			++old_psl;
			continue;
		}
		break;
	}
	for (size_t i = 0; i < strlen(word); ++i) {
		if (ispunct(word[i])) {
			++new_psl;
			continue;
		}
		break;
	}
	// This is just to find which word is longer excluding punctuation;
	// there is probably a smarter way to do this, but it works
	int old_span = strspn(node->word,
			      "abcdefghijklmnopqrstuvwxyzABCEDFGHIJKLMNOPQRSTUVWXYZ");
	int new_span = strspn(word,
			      "abcdefghijklmnopqrstuvwxyzABCEDFGHIJKLMNOPQRSTUVWXYZ");
	if (old_span > new_span) {
		new_span = old_span;
	}

	while (node != NULL) {
		if (strncasecmp(node->word + old_psl, word + new_psl, new_span)
		    == 0) {
			if (file_num != -1) {
				// If file_num is not explicitly set to -1, it is always
				// positive and safe to cast to unsigned; if it is -1,
				// then the word is a duplicate spelling of a word
				// found in the first file.
				node->counter +=
				    (node->counter ==
				     (unsigned)file_num) ? 1 : 0;
			}
			while (node != NULL) {
				if (strcmp(node->word, word) == 0) {
					return;
				} else if (node->alt_next == NULL) {
					hash_node *new_node =
					    malloc(sizeof(hash_node));
					if (!new_node) {
						return;
					}
					new_node->word =
					    malloc(strlen(word) + 1);
					if (!new_node->word) {
						free(new_node);
						return;
					}
					new_node->alt_next = NULL;
					strcpy(new_node->word, word);
					node->alt_next = new_node;
				}
				node = node->alt_next;
			}
		}
		node = node->next;
	}
	return;
}

void hash_set_destroy(hash_set * set)
{
	if (!set) {
		return;
	}
	for (size_t i = 0; i < set->size; i++) {
		hash_node *node = set->table[i];
		while (node != NULL) {
			hash_node *next = node->next;
			hash_node *alt_next = node->alt_next;
			free(node->word);
			free(node);
			if (alt_next != NULL) {
				node = alt_next;
				while (node != NULL) {
					alt_next = node->alt_next;
					free(node->word);
					free(node);
					node = alt_next;
				}
			}
			node = next;
		}
	}
	free(set->table);
	free(set);
}

void hash_set_iterate(hash_set * set, void (*function)(hash_node * node))
{
	if(!set || !function) {
		return;
	}
	for (unsigned i = 0; i < set->size; ++i) {
		hash_node *node = set->table[i];
		while (node != NULL) {
			function(node);
			node = node->next;
		}
	}
}

static int alpha_sort(const void *a, const void *b)
// Sorts given words alphabetically and places null nodes at the end
{
	const hash_node *left = *(const hash_node **)a;
	const hash_node *right = *(const hash_node **)b;
	if (!left && !right) {
		return 0;
	}
	if (!left) {
		return 1;
	}
	if (!right) {
		return -1;
	}
	return strcasecmp(left->word, right->word);
}

void hash_set_to_sorted_list(hash_set * set)
// This is the bottleneck for this project. Having to walk the entire
// array, decoupling linked nodes, and then sorting it all takes a
// substantial amount of time compared to all other functions. 
{
	// This initial code block decouples linked lists made from hash
	// collisions into individual nodes in the set array; this does not
	// seem like the most efficient way to do this, but it was easy 
	// to implement for basic functionality
	unsigned i = 0;
	hash_node *node = NULL;
	while (i < set->size) {
		if (set->table[i] != NULL && set->table[i]->next != NULL) {
			node = set->table[i];
			set->table[i] = node->next;
			node->next = NULL;

			for (unsigned j = 0; j < set->size; ++j) {
				if (set->table[j] == NULL) {
					set->table[j] = node;
					break;
				}
			}
		} else {
			++i;
		}
	}
	qsort(set->table, set->size, sizeof(set->table[0]), alpha_sort);
	return;
}
