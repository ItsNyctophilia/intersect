// Initial hash set syntax originally generated by ChatGPT
// and thoroughly modified to the project's parameters.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Arbitrary starting table size and load factor,
// seems reasonable for default parameters
#define INITIAL_TABLE_SIZE 1000
#define LOAD_FACTOR 0.70

typedef struct hash_node{
	char *word;
	unsigned counter;
	struct hash_node *alt_next;
	struct hash_node *next;
} hash_node;

typedef struct hash_set{
	hash_node **table;
	unsigned size;
	unsigned num_words;
} hash_set;

static unsigned int hash(const char *word, int table_size)
{
	// Arbitrary constant used by the djb2 algorithm
	unsigned hash = 5381;
	for (size_t i = 0; i < strlen(word); i++) {
		hash = ((hash << 5) + hash) + word[i];
	}
	return hash % table_size;
}

hash_set *hash_set_create(void)
{
	hash_set *set = (hash_set *) malloc(sizeof(hash_set));
	set->table =
	    (hash_node **) calloc(INITIAL_TABLE_SIZE, sizeof(hash_node *));
	set->size = INITIAL_TABLE_SIZE;
	set->num_words = 0;
	return set;
}

void hash_set_add_word(hash_set * set, const char *word)
{
	if (!set || !word) {
		return;
	}
	// Casting int to float for float division
	if (((float)set->num_words / set->size) > LOAD_FACTOR) {
		int new_size = set->size * 2;
		hash_node **new_table =
		    (hash_node **) calloc(new_size, sizeof(hash_node *));
		for (size_t i = 0; i < set->size; i++) {
			hash_node *node = set->table[i];
			while (node != NULL) {
				hash_node *next = node->next;
				unsigned index = hash(node->word, new_size);
				node->next = new_table[index];
				new_table[index] = node;
				node = next;
			}
		}
		free(set->table);
		set->table = new_table;
		set->size = new_size;
	}
	unsigned index = hash(word, set->size);
	hash_node *node = set->table[index];
	while (node != NULL) {
		if (strcmp(node->word, word) == 0) {
			return;
		}
		node = node->next;
	}
	node = (hash_node *) malloc(sizeof(hash_node));
	node->word = (char *)malloc(strlen(word) + 1);
	strcpy(node->word, word);
	node->counter = 0;
	node->next = set->table[index];
	set->table[index] = node;
	set->num_words++;
}

int hash_set_contains_word(hash_set * set, const char *word)
{
	if (!set || !word) {
		return(0);
	}
	
	unsigned index = hash(word, set->size);
	hash_node *node = set->table[index];
	while (node != NULL) {
		if (strcmp(node->word, word) == 0) {
			return 1;
		}
		node = node->next;
	}
	return 0;
}

void hash_set_destroy(hash_set * set)
{
	if (!set) {
		return;
	}
	for (size_t i = 0; i < set->size; i++) {
		hash_node *node = set->table[i];	
		while (node != NULL) {
			hash_node *next = node->next;
			hash_node *alt_next = node->alt_next;
			free(node->word);
			free(node);
			if (alt_next != NULL) {
				node = alt_next;
				while (node != NULL) {
					alt_next = node->alt_next;
					free(node->word);
					free(node);
					node = alt_next;
				}
			}
			node = next;
		}
	}
	free(set->table);
	free(set);
}
