// Initial hash set syntax originally generated by ChatGPT
// and thoroughly modified to the project's parameters.
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
// Arbitrary starting table size and load factor,
// seems reasonable for default parameters
#define INITIAL_TABLE_SIZE 1000
#define LOAD_FACTOR 0.70

typedef struct hash_node {
	char *word;
	unsigned counter;
	struct hash_node *alt_next;
	struct hash_node *next;
} hash_node;

typedef struct hash_set {
	hash_node **table;
	unsigned size;
	unsigned num_words;
} hash_set;

void hash_set_add_alts(hash_set * set, const char *word, size_t file_num);

static unsigned int hash(const char *word, int table_size)
{
	// Arbitrary constant used by the djb2 algorithm
	unsigned hash = 5381;
	for (size_t i = 0; i < strlen(word); i++) {
		hash = ((hash << 5) + hash) + tolower(word[i]);
	}
	return hash % table_size;
}

hash_set *hash_set_create(void)
{
	hash_set *set = malloc(sizeof(hash_set));
	if (!set) {
		return NULL;
	}
	set->table = calloc(INITIAL_TABLE_SIZE, sizeof(hash_node *));
	if (!set->table) {
		return NULL;
	}
	set->size = INITIAL_TABLE_SIZE;
	set->num_words = 0;
	return set;
}

void hash_set_add_word(hash_set * set, const char *word)
{
	if (!set || !word) {
		return;
	}
	// Casting int to float for float division
	if (((float)set->num_words / set->size) > LOAD_FACTOR) {
		int new_size = set->size * 2;
		hash_node **new_table = calloc(new_size, sizeof(hash_node *));
		if (!new_table) {
			return;
		}
		for (size_t i = 0; i < set->size; i++) {
			hash_node *node = set->table[i];
			while (node != NULL) {
				hash_node *next = node->next;
				unsigned index = hash(node->word, new_size);
				node->next = new_table[index];
				new_table[index] = node;
				node = next;
			}
		}
		free(set->table);
		set->table = new_table;
		set->size = new_size;
	}
	unsigned index = hash(word, set->size);
	hash_node *node = set->table[index];
	while (node != NULL) {
		if (strcasecmp(node->word, word) == 0) {
			// Case: alternate spelling found in first file
			hash_set_add_alts(set, word, 0);
			return;
		}
		node = node->next;
	}
	node = malloc(sizeof(hash_node));
	if (!node) {
		return;
	}
	node->word = malloc(strlen(word) + 1);
	if (!node->word) {
		free(node);
		return;
	}
	strcpy(node->word, word);
	node->counter = 0;
	node->next = set->table[index];
	node->alt_next = NULL;
	set->table[index] = node;
	set->num_words++;
}

void hash_set_add_alts(hash_set * set, const char *word, size_t file_num)
// Indexes into an already-populated hash set and
// adds alternative spellings of existing nodes on
// the top level to the alt_next chain of that node
{
	if (!set || !word) {
		return;
	}

	unsigned index = hash(word, set->size);
	hash_node *node = set->table[index];
	while (node != NULL) {
		if (strcasecmp(node->word, word) == 0) {
			node->counter += (node->counter == file_num) ? 1 : 0;
			while (node != NULL) {
				if (strcmp(node->word, word) == 0) {
					return;
				} else if (node->alt_next == NULL) {
					hash_node *new_node =
					    malloc(sizeof(hash_node));
					if (!new_node) {
						return;
					}
					new_node->word =
					    malloc(strlen(word) + 1);
					if (!new_node->word) {
						free(new_node);
						return;
					}
					new_node->alt_next = NULL;
					strcpy(new_node->word, word);
					node->alt_next = new_node;
				}
				node = node->alt_next;
			}
		}
		node = node->next;
	}
	return;
}

void hash_set_destroy(hash_set * set)
{
	if (!set) {
		return;
	}
	for (size_t i = 0; i < set->size; i++) {
		hash_node *node = set->table[i];
		while (node != NULL) {
			hash_node *next = node->next;
			hash_node *alt_next = node->alt_next;
			free(node->word);
			free(node);
			if (alt_next != NULL) {
				node = alt_next;
				while (node != NULL) {
					alt_next = node->alt_next;
					free(node->word);
					free(node);
					node = alt_next;
				}
			}
			node = next;
		}
	}
	free(set->table);
	free(set);
}
